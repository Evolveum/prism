//
// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.4 
// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
// Any modifications to this file will be lost upon recompilation of the source schema. 
// Generated on: 2014.02.10 at 06:01:23 PM CET 
//


package com.evolveum.prism.xml.ns._public.types_2;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;
import java.util.ListIterator;

import javax.xml.bind.JAXBElement;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAnyElement;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlMixed;
import javax.xml.bind.annotation.XmlTransient;
import javax.xml.bind.annotation.XmlType;
import javax.xml.namespace.QName;

import com.evolveum.midpoint.prism.xnode.ListXNode;
import com.evolveum.midpoint.prism.xnode.RootXNode;
import com.evolveum.midpoint.util.exception.SystemException;
import org.apache.commons.lang.StringUtils;
import org.apache.commons.lang.Validate;
import org.jvnet.jaxb2_commons.lang.Equals;
import org.jvnet.jaxb2_commons.lang.EqualsStrategy;
import org.jvnet.jaxb2_commons.locator.ObjectLocator;
import org.w3c.dom.Element;

import com.evolveum.midpoint.prism.Containerable;
import com.evolveum.midpoint.prism.Item;
import com.evolveum.midpoint.prism.ItemDefinition;
import com.evolveum.midpoint.prism.Objectable;
import com.evolveum.midpoint.prism.PrismConstants;
import com.evolveum.midpoint.prism.PrismContainer;
import com.evolveum.midpoint.prism.PrismContainerDefinition;
import com.evolveum.midpoint.prism.PrismContainerValue;
import com.evolveum.midpoint.prism.PrismContext;
import com.evolveum.midpoint.prism.PrismProperty;
import com.evolveum.midpoint.prism.PrismPropertyDefinition;
import com.evolveum.midpoint.prism.PrismPropertyValue;
import com.evolveum.midpoint.prism.PrismReference;
import com.evolveum.midpoint.prism.PrismReferenceDefinition;
import com.evolveum.midpoint.prism.PrismReferenceValue;
import com.evolveum.midpoint.prism.PrismValue;
import com.evolveum.midpoint.prism.Referencable;
import com.evolveum.midpoint.prism.parser.DomParser;
import com.evolveum.midpoint.prism.parser.XNodeProcessor;
import com.evolveum.midpoint.prism.path.ItemPath;
import com.evolveum.midpoint.prism.xml.XmlTypeConverter;
import com.evolveum.midpoint.prism.xml.XsdTypeMapper;
import com.evolveum.midpoint.prism.xnode.MapXNode;
import com.evolveum.midpoint.prism.xnode.PrimitiveXNode;
import com.evolveum.midpoint.prism.xnode.ValueParser;
import com.evolveum.midpoint.prism.xnode.XNode;
import com.evolveum.midpoint.util.DOMUtil;
import com.evolveum.midpoint.util.exception.SchemaException;


/**
 * 
 *                 TODO
 *             
 * 
 * <p>Java class for RawType complex type.
 * 
 * <p>The following schema fragment specifies the expected content contained within this class.
 * 
 * <pre>
 * &lt;complexType name="RawType">
 *   &lt;complexContent>
 *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *       &lt;sequence>
 *         &lt;any/>
 *       &lt;/sequence>
 *     &lt;/restriction>
 *   &lt;/complexContent>
 * &lt;/complexType>
 * </pre>
 * 
 * 
 */
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "RawType", propOrder = {
    "content"
})
public class RawType implements Serializable, Equals{
	private static final long serialVersionUID = 4430291958902286779L;
	
	public RawType() {
		content = new ContentList();
	}

    public RawType(XNode xnode) {
        this();
        setXnode(xnode);
    }


    @XmlTransient
	private XNode xnode;
	
	@XmlTransient
	private Object realValue;
	
	@XmlTransient
	private PrismValue parsed;
	
    @XmlMixed
    @XmlAnyElement(lax = true)
    protected List<Object> content;
    
	public XNode getXnode() {
		return xnode;
	}

	public void setXnode(XNode xnode) {
		this.xnode = xnode;
	}


	/**
     * 
     *                 TODO
     *             Gets the value of the content property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the content property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getContent().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link String }
     * {@link Object }
     * 
     * 
     */
    public List<Object> getContent() {
        if (content == null) {
            content = new ContentList();
        }
        return this.content;
        
    }

    public XNode serializeToXNode() throws SchemaException {
        if (xnode != null){
            return xnode;
        } else if (realValue != null) {
            if (XmlTypeConverter.canConvert(realValue.getClass())){
                QName type = XsdTypeMapper.toXsdType(realValue.getClass());
                PrimitiveXNode xprim = new PrimitiveXNode();
                xprim.setValue(realValue);
                xprim.setExplicitTypeDeclaration(true);
                xprim.setTypeQName(type);
                return xprim;
            } else {
                throw new SystemException("Couldn't marshall RawType realValue to XNode; value class: " + realValue.getClass());
            }
        } else if (parsed != null) {
            return parsed.getPrismContext().getXnodeProcessor().serializeItemValue(parsed);
        } else {
            return null;
        }
    }

    class ContentList extends ArrayList<Object>{

			@Override
			public int size() {
				if (realValue != null || xnode != null){
					return 1;
				}
				return super.size();
			}

			@Override
			public boolean isEmpty() {
				if (xnode != null){
					return false;
				}
				return super.isEmpty();
			}

			@Override
			public Iterator<Object> iterator() {
				if (realValue == null && xnode == null){
					return super.iterator();
				}
			
				return new Iterator<Object>() {
					int i = 0;
					@Override
					public boolean hasNext() {
						if (realValue == null && xnode == null){
							return false;
						}
						return (i==0);
					}

					@Override
					public Object next() {
						i++;
						if (realValue != null){
							return new JAXBElement(new QName(PrismConstants.NS_TYPES, "value"), realValue.getClass(), realValue);
						} else
						if (xnode instanceof PrimitiveXNode){
							PrimitiveXNode prim = (PrimitiveXNode) xnode;
//							System.out.println("primitive to serialize: " + prim.debugDump());
							QName typeName = prim.getTypeQName();
							if (typeName == null){
								//assume string..most probably it will be..  FIXME
								typeName = DOMUtil.XSD_STRING;
							}
						 	Class declaredType = XsdTypeMapper.toJavaType(typeName);
//						 	DomParser parser = new DomParser(null);
//						 	try{
//						 		Element e = parser.serializeXPrimitiveToElement(prim, new QName(PrismConstants.NS_TYPES, "value"));
//						 		return e;
						 		try {
									return prim.getParsedValue(typeName);
								} catch (SchemaException e) {
									// TODO: is this exception really needed?? isn't it better to just return string value??
									throw new IllegalStateException("Cannot get value from " + prim);
								}
//						 	}catch (SchemaException ex){
//						 		throw new IllegalStateException(ex.getMessage(), ex);
//						 	}
//							return new JAXBElement(new QName("fake", "fake"), declaredType, prim.getValue());
						}
//						 else if (xnode instanceof MapXNode){
////							throw new UnsupportedOperationException("nto supported yet");
////							MapXNode map = (MapXNode) xnode;
//							 MapXNode map = (MapXNode) xnode;
////							 	Class declaredType = XsdTypeMapper.toJavaType(prim.getTypeQName());
//							 	DomParser parser = new DomParser(null);
//							 	try{
//							 		Element e = parser.serializeXMapToElement(map, new QName(PrismConstants.NS_TYPES, "value"));
//							 		return e;
//							 	}catch (SchemaException ex){
//							 		throw new IllegalStateException(ex.getMessage(), ex);
//							 	}
////							
//						}
						
						throw new UnsupportedOperationException("nto supported yet for xnode: " + xnode + ", realValue " + realValue);
					}

					@Override
					public void remove() {
						throw new UnsupportedOperationException("nto supported yet");
					}
					
				};
			}

			@Override
			public boolean add(Object e) {
				super.add(e);
				if (e instanceof String){
					if (StringUtils.isBlank((String)e)){
						System.out.println("Blank value to add..skipping: => " + e);
						return true;
					}
					final String val = (String) e;
					ValueParser valueParser = new ValueParser() {

						@Override
						public Object parse(QName typeName)
								throws SchemaException {
							return XmlTypeConverter.toJavaValue(val, typeName);
						}

						@Override
						public boolean isEmpty() {
							return StringUtils.isEmpty(val);
						}

						@Override
						public String getStringValue() {
							return val;
						}
					};
					xnode = new PrimitiveXNode();
					((PrimitiveXNode)xnode).setValueParser(valueParser);
					return true;
				} else if (e instanceof JAXBElement){
					JAXBElement jaxb = (JAXBElement) e;
                    if (realValue != null) {
                        throw new IllegalStateException("Multiple real values in a RawType! Current value = " + realValue + ", value to be added = " + jaxb.getValue());
                    }
                    if (xnode != null) {
                        throw new IllegalStateException("Both realValue and XNode present in RawType. Current XNode = " + xnode + ", value to be added = " + jaxb.getValue());
                    }
					realValue = jaxb.getValue();
					return true;
				} else if (e instanceof Element){
					DomParser domParser = new DomParser(null);
					try{
						XNode newXnode = domParser.parseElementContent((Element) e);
                        if (realValue != null) {
                            throw new IllegalStateException("Both realValue and XNode present in RawType. Current real value = " + realValue + ", xnode to be added = " + newXnode);
                        }
                        if (xnode == null) {
                            xnode = newXnode;
                        } else {
                            throw new IllegalStateException("A RawType can contain only one value.");
//                            // remove this code when we definitely decide to have RawType single-valued
//                            if (xnode instanceof ListXNode) {
//                                ((ListXNode) xnode).add(newXnode);
//                            } else {
//                                ListXNode newListXNode = new ListXNode();
//                                newListXNode.add(xnode);
//                                newListXNode.add(newXnode);
//                                xnode = newListXNode;
//                            }
                        }
						return true;
					} catch (SchemaException ex){
						throw new IllegalArgumentException("Cannot parse element: "+e+" Reason: "+ex.getMessage(), ex);
					}
				}
				throw new IllegalArgumentException("RAW TYPE ADD: "+e+" "+e.getClass());
			}

//			@Override
//			public boolean remove(Object o) {
//				throw new UnsupportedOperationException("nto supported yet");
//			}
//
//			@Override
//			public boolean containsAll(Collection<?> c) {
//				throw new UnsupportedOperationException("nto supported yet");
//			}
//
//			@Override
//			public boolean addAll(Collection<? extends Object> c) {
//				throw new UnsupportedOperationException("nto supported yet");
//			}
//
//			@Override
//			public boolean addAll(int index, Collection<? extends Object> c) {
//				throw new UnsupportedOperationException("nto supported yet");
//			}
//
//			@Override
//			public boolean removeAll(Collection<?> c) {
//				throw new UnsupportedOperationException("nto supported yet");
//			}
//
//			@Override
//			public boolean retainAll(Collection<?> c) {
//				throw new UnsupportedOperationException("nto supported yet");
//			}

			@Override
			public void clear() {
				xnode = null;
				realValue = null;
			}

			@Override
			public Object get(int index) {
				if (realValue == null && xnode == null){
					return super.get(index);
				}
				if (realValue != null){
					return new JAXBElement(new QName(PrismConstants.NS_TYPES, "value"), realValue.getClass(), realValue);
				} else
				if (xnode instanceof PrimitiveXNode){
					PrimitiveXNode prim = (PrimitiveXNode) xnode;
				 	Class declaredType = XsdTypeMapper.toJavaType(prim.getTypeQName());
				 	DomParser parser = new DomParser(null);
				 	try{
				 		Element e = parser.serializeXPrimitiveToElement(prim, new QName(PrismConstants.NS_TYPES, "value"));
				 		return e;
//				 		return prim.getStringValue();
				 	}catch (SchemaException ex){
				 		throw new IllegalStateException(ex.getMessage(), ex);
				 	}
//					return new JAXBElement(new QName("fake", "fake"), declaredType, prim.getValue());
				}
//				 else if (xnode instanceof MapXNode){
////					throw new UnsupportedOperationException("nto supported yet");
////					MapXNode map = (MapXNode) xnode;
//					 MapXNode map = (MapXNode) xnode;
////					 	Class declaredType = XsdTypeMapper.toJavaType(prim.getTypeQName());
//					 	DomParser parser = new DomParser(null);
//					 	try{
//					 		Element e = parser.serializeXMapToElement(map, new QName(PrismConstants.NS_TYPES, "value"));
//					 		
//					 		return e;
//					 	}catch (SchemaException ex){
//					 		throw new IllegalStateException(ex.getMessage(), ex);
//					 	}
////					
//				} 
				
				throw new UnsupportedOperationException("nto supported yet for xnode: " + xnode + ", realValue " + realValue);
//				throw new UnsupportedOperationException("nto supported yet");
			}
//
//			@Override
//			public Object set(int index, Object element) {
//				throw new UnsupportedOperationException("nto supported yet");
//			}
//
//			@Override
//			public void add(int index, Object element) {
//				throw new UnsupportedOperationException("nto supported yet");
//			}
//
//			@Override
//			public Object remove(int index) {
//				throw new UnsupportedOperationException("nto supported yet");
//			}
//
//			@Override
//			public int indexOf(Object o) {
//				throw new UnsupportedOperationException("nto supported yet");
//			}
//
//			@Override
//			public int lastIndexOf(Object o) {
//				throw new UnsupportedOperationException("nto supported yet");
//			}
//
//			@Override
//			public ListIterator<Object> listIterator() {
//				throw new UnsupportedOperationException("nto supported yet");
//			}
//
//			@Override
//			public ListIterator<Object> listIterator(int index) {
//				throw new UnsupportedOperationException("nto supported yet");
//			}
//
//			@Override
//			public List<Object> subList(int fromIndex, int toIndex) {
//				throw new UnsupportedOperationException("nto supported yet");
//			}
        	
        
	}

        public Object getRealValue(){
        	return realValue;
        }

    // itemDefinition may be null; in that case we do the best what we can
	public <V extends PrismValue> V getParsedValue(ItemDefinition itemDefinition, QName itemName) throws SchemaException {
		V value = null;
		
		if (parsed != null){
			return (V) parsed;
		}

		if (xnode != null) {
			System.out.println("xnode: " + xnode.debugDump());
			if (itemDefinition != null) {
				PrismContext prismContext = itemDefinition.getPrismContext();
				Item<V> subItem = prismContext.getXnodeProcessor().parseItem(xnode, itemDefinition.getName(),
						itemDefinition);
				value = subItem.getValue(0);
				xnode = null;
			} else { 
				PrismProperty<V> subItem = XNodeProcessor.parsePrismPropertyRaw(xnode, itemName);
				value = (V) subItem.getValue();
				xnode = null;
			}
		} else {
			if (itemDefinition == null) {
				throw new SchemaException("No definition for item " + realValue
						+ " (parsed from raw element)");
			}
			if (itemDefinition instanceof PrismPropertyDefinition<?>) {
				// property
				if (realValue != null) {
					PrismPropertyValue ppValue = new PrismPropertyValue(realValue);
					value = (V) ppValue;
				}

			} else if (itemDefinition instanceof PrismContainerDefinition<?>) {
				if (realValue instanceof Containerable) {
					PrismContainerValue subValue = ((Containerable) realValue).asPrismContainerValue();
					value = (V) subValue;
				} else {
					throw new IllegalArgumentException("Unsupported JAXB bean " + realValue.getClass());
				}
			} else if (itemDefinition instanceof PrismReferenceDefinition) {
				// TODO
				if (realValue instanceof Referencable) {
					PrismReferenceValue refValue = ((Referencable) realValue).asReferenceValue();
					value = (V) refValue;
				} else if (realValue instanceof Objectable) {
					// TODO: adding reference with object??
					PrismReferenceValue refVal = new PrismReferenceValue();
					refVal.setObject(((Objectable) realValue).asPrismObject());
					value = (V) refVal;
				} else {
					throw new IllegalArgumentException("Unsupported JAXB bean" + realValue);
				}

			} else {
				throw new IllegalArgumentException("Unsupported definition type " + itemDefinition.getClass());
			}

		}
		parsed = value;
		return value;
	}

//    /**
//     * Expects that there is a root Xnode-like situation: that the XNode is a map with one entry with a name
//     * that can be used to find a definition of the item. (TODO provide more universal interface to retrieve
//     * both atomic content and this kind of content.)
//     */
//    public <V extends PrismValue> Item<V> getParsedItem(PrismContext prismContext) throws SchemaException {
//        if (parsed != null) {
//            if (parsed.getParent() == null) {
//                throw new IllegalStateException("RawType with a parsed value having no parent");
//            }
//            return (Item<V>) parsed.getParent();
//        }
//        XNode xnode = serializeToXNode();           // it is possible that there is no XNode, only realValue, TODO optimize by skipping this transformation
//        if (xnode instanceof MapXNode)
//        Item<V> item = prismContext.
//    }

    public <V extends PrismValue> Item<V> getParsedItem(ItemDefinition itemDefinition) throws SchemaException {
        Validate.notNull(itemDefinition);
        return getParsedItem(itemDefinition, itemDefinition.getName());
    }

    public <V extends PrismValue> Item<V> getParsedItem(ItemDefinition itemDefinition, QName itemName) throws SchemaException {
        Validate.notNull(itemDefinition);
        Validate.notNull(itemName);
        Item<V> item = itemDefinition.instantiate();
        V newValue = getParsedValue(itemDefinition, itemName);
        item.add(newValue);
        return item;
    }

    // Shallow clone. Do we need deep clone?
    public RawType clone() {
    	RawType clone = new RawType();
    	clone.setXnode(xnode);
        for (Object o : getContent()) {
            clone.getContent().add(o);
        }
    	return clone;
    }
    
	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + ((xnode == null) ? 0 : xnode.hashCode());
		result = prime * result + ((realValue == null) ? 0 : realValue.hashCode());
        result = prime * result + ((parsed == null) ? 0 : parsed.hashCode());
		return result;
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		RawType other = (RawType) obj;
		if (xnode == null) {
			if (other.xnode != null)
				return false;
		} else if (!xnode.equals(other.xnode))
			return false;
		return true;
	}
	
	@Override
	public boolean equals(ObjectLocator thisLocator, ObjectLocator thatLocator, Object that,
			EqualsStrategy equalsStrategy) {
		boolean res = equals(that);
		System.out.println("raw type equals: " + res);
		if (!res){
			System.out.println("this " + this.xnode.debugDump());
			System.out.println("that " + ((RawType)that).getXnode().debugDump());
		}
		return res;
//		if (!(that instanceof ItemPathType)){
//    		return false;
//    	}
//    	
//    	ItemPathType other = (ItemPathType) that;
//    	
//    	ItemPath thisPath = getItemPath();
//    	ItemPath otherPath = other.getItemPath();
//    	
//    	if (thisPath != null){
//    		return thisPath.equivalent(otherPath);
//    	}
//    	
//    	List<Object> thsContent = getContent();
//    	List<Object> othContent = other.getContent();
    	
//    	return equalsStrategy.equals(thisLocator, thatLocator, thsContent, othContent);
    	
	}

}
